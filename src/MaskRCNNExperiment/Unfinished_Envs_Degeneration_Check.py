# This scrip is used for evaluation of unfinished environments generated by testing models.
# Due to changes in generation of data we altered degeneration criteria many times. This script will
# load all levels in selected unfinished environments pickle files and check its degeneration. Note that,
# at the moment of training/ inference those configuration were considered not degenerated
# (other wise they wouldn't be generated). So this script returns number of configurations that were previously
# considered as not degenerated and now are.

import os
import sys
import pickle
ROOT_DIR = os.path.abspath("../")
sys.path.append(ROOT_DIR)
from py_euclidea import multi_level
from LevelSelector import LevelSelector



if __name__ == "__main__":
    # Parse arguments
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("--folder_with_models", default="../logs/Beta_as_whole", type=str,
                        help="folder with trained models")
    args = parser.parse_args()

    for i in os.listdir(args.folder_with_models):

        num_of_degenerated = 0
        model_path = os.path.join(args.folder_with_models, i)

        #levels = LevelSelector.get_levels(i.replace("-", ".*")[0:6])
        levels = LevelSelector.get_levels("beta.*")
        if os.path.exists(os.path.join(model_path, "unfinished_levels")):
            with open(os.path.join(model_path, "unfinished_levels"), "rb") as file:
                failed_envs = pickle.load(file)
        else :
            failed_envs = []
        m = multi_level.MultiLevel((levels))
        for l in failed_envs:
            level_index = m.next_level(None, l)
            env = m.cur_env
            bb = env.get_bounding_box()
            deg = env.is_degenerated(1, (bb[0]+bb[1])/2)
            if deg:
                num_of_degenerated += 1
        print("{} -> newly degenerated: {}/{}".format(i, num_of_degenerated, len(failed_envs)))





